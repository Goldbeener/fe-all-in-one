
**权限是定义在位置places上的**，
不仅仅是变量
**位置是任何可以放在赋值语句左边的东西**

位置包括
1. 变量 如`a`
2. 位置的解引用 `*a`
3. 位置的数组访问 `a[0]`
4. 位置的字段访问 `a.0` 或 `a.field`
5. 上述的任何组合

当位置变成不使用的时候，会失去权限


引用和解引用机制

```rust
let a: i32 = 1;
let b: &i32 = &a;
let c: i32 = *b; 
```

注意上述类型声明

变量a拥有一个值，可以访问这个值；
变量b借用了变量a； 变量b可以通过访问a得以访问这个值；
变量c是 变量b的解引用； 可以直接获取这个值； 

解引用是操作、是一个表达式，计算的结果是内存中的值， 与a所拥有的值是同一个，并不是复制，而是透过引用查看或者访问原始值。 

> 也就是说**解引用是瞬时访问操作**，查看/访问某一时刻某个引用对应的值。

解引用可以理解为一个语法糖，背后还是通过引用关系来获取/修改数据
因此解引用与原引用的权限是关联的
如果是一个不可变引用的解引用，那么解引用还是无法修改数据的

再延伸一下，如果原变量是不可修改的
那么对原变量的引用，也无法修改数据；进而解引用也无法修改数据



**值不可以同时被引用和修改**
也就是一个值，如果存在在用的引用，那么这个值在此期间不能被修改


`let mut v = vec!([1,2,3]);`
`mut` 标识符的双重含义:
1. **重新绑定权限**：指代变量v可以重新被赋值为新的值；
2. **内容修改权限**：代表通过变量v可以操作对应的值

也就是说mut标识符有两重含义，
1. 是代表后面的变量可以重新拥有新的值； 
2. 代表如果当前拥有的值是可变的，比如vec、元组、数组、结构体等，那么可以通过变量操作更新值

延伸一下，如果`let x = vec!([1,2,3])`
那么堆中存储的这段数据(在正常情况下哎)就永远不可能变化，直到被回收


再延伸一下
```rust
let mut v: i32 = 1;
v = v + 1;
```
这种基础值，
在初始化赋值时只会分配所需的内存空间， 不会预留额外的空间
更新的时候，在原内存位置直接覆盖


```rust
let mut v = vec!([1,2,3]);
v.push(4);
```
对于动态数据结构
在初始化赋值时，会分配大于必要的内存空间，预留额外的空间
这样后续更新时，可能直接在预留的内存空间上操作
避免了重新分配内存、复制旧数据、释放旧内存的昂贵流程


**可变引用**提供对数据**唯一**的且**非拥有**的访问
可变引用   独占引用
不可变引用 共享引用


权限在引用声明周期结束时被返回

数据必须在其所有的引用存在期间存活，也就是有引用期间，不能被回收。

流动权限F： 在**表达式使用输入引用**或**返回输出引用**时需要
F权限在函数体内不会发生变化
如果一个引用被允许在特定表达式中使用，那么它就具有F权限。

借用检查，看的是借用的**生命周期重叠**。



Slice 是特殊引用类型，因为他们是宽指针，带有元数据。

**字符串字面值是切片**
`&str` 是指向二进制文件特定位置的切片

这样是为什么字符串字面量是不可变的，因为它本质是一个不可变的引用。

