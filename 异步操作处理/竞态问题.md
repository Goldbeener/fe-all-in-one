# 原因
无法保证异步操作的完成，是按照他们开始时同样的顺序

相同的请求，按顺序发起，先发起的请求可能最后完成

常出现的场景：
1. 分页列表，快速的切换第二页、第三页。。。
2. 先后请求Data2、Data3，分页器显示当前在第三页
3. 但由于网络的不确定性，有可能Data3比Data2先返回
4. 这样分页器停留在第三页，但是页面显示的是Data2

常见于搜索、分页、选项卡切换等



# 解决方案
1. 取消请求
2. 忽略请求

## 取消请求
后面发起的请求，取消前面正在进行中的请求

### xhr 请求取消
```js
const xhr = new XMLHttpRequest();

xhr.open('GET', '//xxx.com');
xhr.send();

xhr.abort()
```

### Fetch 请求取消
```js
const controller = new AbortController();
const signal = controller.signal;

fetch('//xxx.com', { signal })
	.then(res => { })

controller.abort();
```

### 可取消的Promise

指令式Promise

```js
const { resolve, reject, cancel } = createDirectivePromise(promise);

resolve('xxx');
reject('xxx);

cancel();
```


利用闭包，将promise的操作方法暴露在外面，指令式调用

```js
function createDirectivePromise(promiseFn) {
	let resolve, reject;

	const innerPromise = new Promise((res, rej) => {
		resolve = res;
		reject = rej;
	})

	promiseFn && promiseFn.then(
	(res) => {
		resolve && resolve(res)
	}, 
	(err) => {
		reject && reject(err)
	});

	return {
		resolve: (res) => {
			resolve && resolve(res)
		}
		reject: (err) => {
			reject && reject(err)
		}
		cancal: () => {
		// cancel 就是直接将resolve、reject置为null；promise永远不会有结果
			resolve = null;
			reject = null; 
		}
	}

}
```

## 忽略请求
