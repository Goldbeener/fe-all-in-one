
**权限是定义在位置places上的**，
不仅仅是变量
**位置是任何可以放在赋值语句左边的东西**

位置包括
1. 变量 如`a`
2. 位置的解引用 `*a`
3. 位置的数组访问 `a[0]`
4. 位置的字段访问 `a.0` 或 `a.field`
5. 上述的任何组合

当位置变成不使用的时候，会失去权限


引用和解引用机制

```rust
let a: i32 = 1;
let b: &i32 = &a;
let c: i32 = *b; 
```

注意上述类型声明

变量a拥有一个值，可以访问这个值；
变量b借用了变量a； 变量b可以通过访问a得以访问这个值；
变量c是 变量b的解引用； 可以直接获取这个值； 

解引用是操作、是一个表达式，计算的结果是内存中的值， 与a所拥有的值是同一个，并不是复制，而是透过引用查看或者访问原始值。 

> 也就是说**解引用是瞬时访问操作**，查看/访问某一时刻某个引用对应的值。



**值不可以同时被引用和修改**
也就是一个值，如果存在在用的引用，那么这个值在此期间不能被修改


`let mut v = vec!([1,2,3]);`
`mut` 标识符的双重含义:
1. **重新绑定权限**：指代变量v可以重新被赋值为新的值；
2. **内容修改权限**：代表通过变量v可以操作对应的值

也就是说mut标识符有两重含义，
1. 是代表后面的变量可以重新拥有新的值； 
2. 代表如果当前拥有的值是可变的，比如vec、元组、数组、结构体等，那么可以通过变量操作更新值

延伸一下，如果`let x = vec!([1,2,3])`
那么堆中存储的这段数据(在正常情况下哎)就永远不可能变化，直到被回收


再延伸一下
```rust
let mut v: i32 = 1;
v = v + 1;
```
这种基础值，
在初始化赋值时只会分配所需的内存空间， 不会预留额外的空间
更新的时候，在原内存位置直接覆盖


```rust
let mut v = vec!([1,2,3]);
v.push(4);
```
对于动态数据结构
在初始化赋值时，会分配大于必要的内存空间，预留额外的空间
这样后续更新时，可能直接在预留的内存空间上操作
避免了重新分配内存、复制旧数据、释放旧内存的昂贵流程


**可变引用**提供对数据**唯一**的且**非拥有**的访问
