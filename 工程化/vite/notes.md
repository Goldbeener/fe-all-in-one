浏览器并不知耻ES模块，因此开发者不能直接以模块化的方式进行开发和部署
所以有了各种各样的打包器

打包器的工作就是：抓取、处理将开发中使用的源码模块串联成可以在浏览器中运行的文件

随着JS构建应用规模的扩大，目前市面上的打包器存在的问题
1. 冷启动缓慢， 打包器需要抓取并构建整个应用，才能提供服务
2. 热替换缓慢

Vite实现的基础依据：
浏览器开始原生支持ES模块
越来越多的JS工具使用编译型语言编写

Vite的解决方案：

**缓慢的服务器启动**
一开始，将应用中的模块区分为 **依赖** 和 **源码**

依赖，开发时不会变动的纯JS，使用esbuild预构建依赖，将CommonJS/UMD转换成ESM格式
源码，开发者编写的需要转换的非JS文件，JSX、CSS、Vue组件等；这部分内容基于路由拆分，按需加载，并不是直接处理、加载应用的所有模块

Vite以原生ESM方式提供源码，Vite只需要在浏览器请求源码时进行转换并按需提供源码，
也就是只需要提供页面展示内容对应的模块，并且只需要做转换工作

也就是说在开发环境，所有的模块都是以ESM形式提供的


**缓慢的更新**
Vite的HMR是在原生ESM上执行的，
一个ESM更新时，Vite精准的使已编辑的模块与其最近的HMR边界之间的链失活

同时利用HTTP缓存加速页面加载
依赖模块使用强缓存持久存储，一旦缓存不需要再次请求
源码模块会使用304协商缓存

**开发环境和生产环境区别**
开发环境，ESBuild + ESM
生产环境，使用rollup打包输出产物


Vite组成
一个开发服务器
一套构建指令

生产构建，默认情况下目标浏览器支持原生ES模块、原生ESM动态导入、import.meta、nullish coalescing、BigInt



开发期间vite是一个服务器，index.html 是vite项目的入口文件，因此index.html
是在项目根目录下

根目录
入口文件、vite配置所在



功能
+ npm依赖解析和预构建
+ 模块热替换
+ ts支持，仅转译，不校验
+ HTML处理，会作为应用的一部分进行处理和打包，也就是修改html内容
+ vue文件支持
+ JSX/TSX  开箱即用，但是vue项目需要额外加上 `@vitejs/plugin-vue-jsx` 插件
+ CSS
+ PostCSS
+ CSS Modules
+ CSS 预处理器
+ Lightning CSS
+ 静态资源处理
+ JSON
+ Glob 导入
+ 动态导入
+ WebAssembly


css预处理器
css modules
PostCSS 
三者的关系以及作用，是否可以搭配使用，以及在整个编译周期所处的位置和前后顺序
