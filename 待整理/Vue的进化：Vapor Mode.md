1. Vue框架要解决的问题
2. vdom
3. vdom+编译器 优化
4. vapor mode
5. vapor mode应用场景


视图框架要解决的问题： **状态与UI的同步问题**

关键的两个方面： 状态维护和UI更新绘制

在前端范畴内 
**声明式编程** 偏重于UI的绘制更新，并且强调期望界面是什么，而不是界面某时某刻应该怎么更新
**数据驱动** 更偏重于状态的维护，以数据的状态或结构来主导程序的控制流

**声明式编程**  声明式描述视图，描述的是视图的期望结果，而不是命令式的操纵整个视图的变化过程 ，在前端范畴内偏重于UI的绘制更新

**数据驱动视图**   数据是现代框架的核心，视图是数据的映射 

vdom 的由来
是**声明式编程思想指导下的具体实现**

首先框架想要实现声明式编程，不手动操作dom， 
那如何实现呢？ 
vdom 是其中的一个实现方式

打包之后，页面结构以渲染函数的形式存在，
页面打开的的时候，执行渲染函数，动态生成页面并渲染

1. 将当前页面结构以js对象（vdom）的形式维护在内存中
2. 页面需要更新时，先产生一个新页面的vdom
3. 对比新旧vdom，找到两者最小化差异
4. 调用真实dom api，更新页面


**优点**
1. 提高了**页面dom更新**的效率， 注意不是dom操作的效率，是dom更新的效率
	1. 因为通过dom diff 找到了最小化的dom操作集合，减少了中间态无用的dom操作
	2. 但并不是提高了真实dom操作的效率
2. 可以实现跨平台
	1. 页面结构以数据形式存在，可以方便接入不同平台的api，转换成对应平台的页面实现

**缺点**
1. 首评渲染效率问题，dom结构都是从vdom转换来的，在首评的时候会有更多的白屏时间
2. 额外的运行时内存，因为始终在内存中维护一份页面结构对应的vdom数据
3. 复杂页面更新问题，dom diff以组件为单位，组件内任何细小的更新，需要遍历整个组件的vdom，确认最终的更新点



Vue3 针对这些做了优化

1. 在vdom的基础上做优化 
	1. Static Hoist
	2. Patch Flag
2. vapor mode
	1. 抛弃vdom



vapor mode
一种不使用vdom的编译模式

将模板渲染成真实node节点，
并且建立响应式数据与相关node的映射关系
在数据变更时，直接操作需要变更的node做相应更新，实现细粒度更新

不需要diff操作，找到需要的dom更新行为


更小的包体积
更高效的dom更新
更少的运行时内存占用


应用场景：
1. 大组件
2. 极致的性能要求


