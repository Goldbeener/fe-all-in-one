
变量绑定
变量可变性

变量遮蔽

浮点数陷阱
1. 避免在浮点数上测试相等性
2. 结果在数学上可能存在未定义 NAN
数值可以使用方法

类型转换必须是显式的


**权限是定义在位置places上的**，
不仅仅是变量
**位置是任何可以放在赋值语句左边的东西**

位置包括
1. 变量 如`a`
2. 位置的解引用 `*a`
3. 位置的数组访问 `a[0]`
4. 位置的字段访问 `a.0` 或 `a.field`
5. 上述的任何组合

当位置变成不使用的时候，会失去权限


引用和解引用机制

```rust
let a: i32 = 1;
let b: &i32 = &a;
let c: i32 = *b; 
```

注意上述类型声明

变量a拥有一个值，可以访问这个值；
变量b借用了变量a； 变量b可以通过访问a得以访问这个值；
变量c是 变量b的解引用； 可以直接获取这个值； 

解引用是操作、是一个表达式，计算的结果是内存中的值， 与a所拥有的值是同一个，并不是复制，而是透过引用查看或者访问原始值。 

> 也就是说**解引用是瞬时访问操作**，查看/访问某一时刻某个引用对应的值。

解引用可以理解为一个语法糖，背后还是通过引用关系来获取/修改数据
因此解引用与原引用的权限是关联的
如果是一个不可变引用的解引用，那么解引用还是无法修改数据的

再延伸一下，如果原变量是不可修改的
那么对原变量的引用，也无法修改数据；进而解引用也无法修改数据


引用在rust中算是一种数据类型
在rust数据操作中，是对数据严格校验的，先确认类型再进行操作
如果类型不匹配的话，不允许操作


**值不可以同时被引用和修改**
也就是一个值，如果存在在用的引用，那么这个值在此期间不能被修改

**可变引用同时只能存在一个**
**可变引用和不可变引用不能同时存在**

可以通过大括号来解决一些所有权问题，手动限制变量的作用域


`let mut v = vec!([1,2,3]);`
`mut` 标识符的双重含义:
1. **重新绑定权限**：指代变量v可以重新被赋值为新的值；
2. **内容修改权限**：代表通过变量v可以操作对应的值

也就是说mut标识符有两重含义，
1. 是代表后面的变量可以重新拥有新的值； 
2. 代表如果当前拥有的值是可变的，比如vec、元组、数组、结构体等，那么可以通过变量操作更新值

延伸一下，如果`let x = vec!([1,2,3])`
那么堆中存储的这段数据(在正常情况下哎)就永远不可能变化，直到被回收


再延伸一下
```rust
let mut v: i32 = 1;
v = v + 1;
```
这种基础值，
在初始化赋值时只会分配所需的内存空间， 不会预留额外的空间
更新的时候，在原内存位置直接覆盖


```rust
let mut v = vec!([1,2,3]);
v.push(4);
```
对于动态数据结构
在初始化赋值时，会分配大于必要的内存空间，预留额外的空间
这样后续更新时，可能直接在预留的内存空间上操作
避免了重新分配内存、复制旧数据、释放旧内存的昂贵流程


**可变引用**提供对数据**唯一**的且**非拥有**的访问
可变引用   独占引用
不可变引用 共享引用


权限在引用声明周期结束时被返回

数据必须在其所有的引用存在期间存活，也就是有引用期间，不能被回收。

流动权限F： 在**表达式使用输入引用**或**返回输出引用**时需要
F权限在函数体内不会发生变化
如果一个引用被允许在特定表达式中使用，那么它就具有F权限。

借用检查，看的是借用的**生命周期重叠**。


**悬垂引用**
真实值比指针更早被释放


复合类型
+ 字符串类型
	+ 切片是String类型中某一部分的引用
+ 元组
+ 结构体
+ 枚举
+ 数组

字符串切片

字符串无法进行索引操作，因为字符串在内存中的存储格式是字节数组，单位是字节
但是实际字符并不是都以一个字节存储的，不能保证每个索引对应的字节就是一个字符边界
索引操作得到的值可能是字符的一部分编码；是无效的。

字符 -- 字形簇
字节 -- byte 可能不是一个完整的字符


所有引用都是一种类型，或者说**Rust中引用是一种特殊的数据类型**

Slice 是特殊引用类型，因为他们是宽指针，带有元数据。

**字符串字面值是切片**
`&str` 是指向二进制文件特定位置的切片

这样是为什么字符串字面量是不可变的，因为它本质是一个不可变的引用。

**对一个变量的部分数据进行引用，会影响整个变量的可操作性**

比如对Vec和数组的某一项引用，会影响整个Vec和数组的操作性


格式说明符

主说明符
1. `空白` display用于用户友好输出  适用于实现了display Trait的类型
2. `?` 调试说明符 适用于实现了debug Trait的所有类型
3. `x` 将整数格式化为小写十六进制 适用于整数类型
4. `X` 将整数格式化为大写十六进制 适用于整数类型
5. `o` 将整数格式化为八进制 适用于整数类型
6. `b` 将整数格式化为二进制 适用于整数类型
7. `p` 以十六进制格式化指针值（地址） 适用于指针类型
8. `e` 科学计数法（小写e） 适用于浮点数
9. `E` 科学计数法（大写E） 适用于浮点数

修饰符
1. `#` 美观打印
2. `0` 用0填充
3. `<` `^` `>` 对齐方式
4. `数字` 宽度
5. `.+数字`  精度
6. `+` 强制符号，总是显示正负号

结构体Struct
1. `关联函数` 
	1. 结构体的上下文中定义的函数，不以`self`为参数, 类似JS中的`静态方法`
	2. 提供与结构体相关但是不依赖于实例的功能，不操作实例
		1. 构造函数
		2. 工具函数
		3. 工厂模式
		4. 配置函数
2. `方法` 
	1. 结构题上下文中定义的函数，以`self`为**第一个参数**, 可以是转移`self` 、不可变借用`&self` 可变借用`&mut self`等形式
	2. 提供对结构体实例的操作，允许我们以面向对象的方式使用结构体
		1. 操作或查询实例数据
		2. 实现trait
		3. 想要链式调用

在结构体内，
如果一个上下文函数需要操作实例self，那么就应该设计为方法，将self作为第一个参数
如果一个上下文函数完全不需要操作实例self，那就应该设计为关联函数


match 表达式 与 所有权
match 表达式与函数调用类似，会影响参数的所有权

模块
1. 内联模式， 在当前文件内寻找模块
2. 当前文件同级的同名文件
3. 同名文件夹下/mod.rs

 **绝对路径**： 从crate模块开始， 同一个crate内，用crate开始；不同crate同一个project，从projectName开始
 **相对路径**： 从所在模块开始， self/super等

模块内所有内容默认对父模块是私有；因此父模块不能使用子模块内容
但是子模块可以向上使用父模块的内容


常见的集合

**元组 tuple**
固定长度
不同类型

解构访问
点访问

每一项没有一个语意化的表示

因此 产生了 结构体

**结构体 Struct**
点访问结构体字段

**枚举类型 Enum**

任何类型的数据都可以放入枚举成员中


**Array**
数组

1. 长度固定
2. 类型相同
3. 线性排列

存储在栈上，速度快


**切片的本质是一个引用**

**Vectors**
动态数组
1. 单一数据结构存储多个值
2. 在内存中连续存储
3. 元素类型相同

**String**
**字节的集合** ？ 还是字符的集合？
可变、可增长、拥有所有权、UTF-8编码的字符串类型

Rust核心语言： str （&str）

&str 长度固定的字符串切片
String： 可动态增长的字符串

因为String在rust概念中是字节的集合
因此，正常的方法是
```rust
let mut s = String::from("lo")
s.push('l')； // 字符的集合，所以向集合内再次添加字符时，使用push犯法
println!("{s}"); // lol

s.push_str("legend"); // push_str 接收一个字符串切片，相当于是push包装的一个语法糖，批量插入多个字符
```

rust中`char`是字符，对应的是unicode标量值；

`字形簇`是用户直觉上的字符，看到几个就是几个；但是一个字形簇背后可能对应多个unicode标量，也就是多个char字符。

在计算机中存储字符串，是以`字节`形式存储的

rust中不允许通过索引直接访问String中的字符，
1. rust中String是字节的结合，但是并不是一个字符对应一个字节，通过索引得到的是字节的值，有可能不是一个完整的字符，而是字符的一部分unicode值
2. 索引操作通常被期望时间复杂度为常数时间O（1）； 但是对于String来说是无法保证的，因为rust必须从头开始遍历内容直到指定索引以确定有多少个有效字符，因此无法实现恒定时间复杂度的访问操作

遍历String
1. 单个Unicode标量值 `.chars()`
2. `.bytes()` 获得原始 字节值



**模式匹配**
match 表达式 
必须要穷举出所有可能，可以使用`_`代表未列出的所有可能性
分支必须是表达式
模式绑定，从模式中取出绑定的值

match 表达式 适用于需要详细**关注每一个分支内容**的场景；

如果只关心分支场景中的一个，忽略其他的分支

可以使用 `if let`

```rust
if let <pattern> = <expression> { //尝试用右边的表达式去匹配左边的模式
    // 代码块
}

if let Some(3) = v {
	println!("three");
}
```

模式匹配， 模式是用来拆解（解构）一个值的语法


序列只允许用于数字或字符类型，因为它们是可以连续的


**方法**

```rust
/**
结构体定义，分两个部分
1. data 部分， 属性定义
2. methods 部分, 分为关联函数和方法， 二者的区别是第一个参数是否是self
*/ 
struct Circle {
	x: f64,
	y: f64,
	radius: f64,
}

impl Circle {
	// 关联函数
	fn new(x: f64, y: f64, radius: f64) -> Circle {
		Circle {
			x,
			y,
			radius
		}
	}
	// 方法 第一个参数必须是self，或者&self, &mut self
	fn area(&self) {
		std::f64::consts::PI * (self.radius * self.radius)
	}
}
```