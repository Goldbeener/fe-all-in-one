## 数据类型

标量类型
1. 整数  Integer
2. 浮点数 Floating
3. 布尔值 Boolean
4. 字符 Character

复合类型
Tuple 不同数据类型的集合、固定长度
Array 元素类型相同，固定长度  

### `数值`
	+ 整数
		+ 有符号整数
			+ i8、i16、i32、i64、i128、isize
		+ 无符号整数
			+ u8、u16、u32、u64、u128、usize
	+ 浮点数
		+ f32 32位浮点数，单精度
		+ f64 64位浮点数，双精度（默认）
	 
**各自的应用场景**

- **整数默认用 `i32`**（除非要特别大，才用 `i64`/`u64`）。
- **浮点默认用 `f64`**（除非性能瓶颈，才考虑 `f32`）。
- **索引用 `usize`**（数组/切片/Vec 索引必须用它）。

### `字符串`
	+ &str 字符串切片 字面量
	+ String  堆上可变字符串
	+ char Unicode标量值  单个字符

**两个字符串类型的区别，应用场景？**

`&str` **字符串切片**

**不可变、引用**，
本质是UTF-8编码的字节序列**借用**

> 类似一个系统创建的常量，已经声明创建即不可变，后续只能只读
> 或者从另一个String借用、延伸

常见形式， 字符串字面量

特点：
零拷贝、轻量、高效

使用场景：
1. `函数参数`， 函数参数是引用传递
2. `只读字符串`， 日志打印、配置项等

`String` 堆分配字符串

可变、拥有所有权，存储在堆上
本质是一个UTF-8字节数组`(Vec<u8>)`的包装

> 有点类似字符串对象，可以对这个对象进行操作

特点：
可以**动态增长**、**修改**

使用场景：
1. 需要拼接、构建新字符串
2. 从用户输入、文件读取、网络请求得到的数据



+ `数组`
	+ [type; n] 固定长度n的数组
	+ vec![1，2] 动态长度数组 vector

+ `结构体`

struct objName { x: i32 }

## 分支与循环

rust 中 if 是表达式，可以返回值


## 函数
1. 必须做类型声明，参数类型和返回值类型
2. **函数最后一行如果没有分号，表示返回值**


异步函数，需要借助三方库
```rust
async fn fetch_data() {
	let res = reqwest::get("...").await.unwrap()
}
```


{} 在rust中 
1. 是一个表达式
2. 一个语法作用

可以把一个表达式，赋值给一个变量

rust中的表达式
1. {}
2. if 表达式
3. loop 表达式 
4. match 表达式

使用Box的集合， 也就是需要考虑所有权的数据类型
1. Vec
2. String
3. HashMap


如果一个变量**拥有**一个Box，当Rust释放该变量的frame时，
Rust会释放该Box的堆内存（Heap）。 

如果变量X将堆数据的所有权移动给另一个变量Y（赋值操作
），那么移动后，X不能再使用。

避免移动
1. clone方法， 真实的复制heap区域内的数据，也就是heap内存在两份数据，x、y相互之间并不干扰



rust是静态类型检查语言
意味着**类型检查是在编译阶段**；

在if条件语句中，编译器会进行更严格的检查；也就是会考虑true/false 双向条件下的情况，也就意味着即使从开发者角度来看，**某条分支永远不可能被执行，但是发生在其中的所有权转移行为，也会影响程序编译**。

**引用** & 是没有所有权的指针
是指向引用变量的指针，通过引用变量再获取heap中的值，并不是持有heap中的位置的指针

**解引用** `*`  


别名数据 

> 如何算是别名数据？

无所有权的指针，就是在临时创建别名

数据不应同时 “被别名引用” 和 “具有可变性”

**不可能多个指针同时拥有同一块数据**
**一个数据在任一时刻只有一个所有者**

被所有的数据只能通过其所有者来访问，不能通过别名来访问/





















